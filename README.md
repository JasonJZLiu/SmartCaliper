## 1. Inspiration
The _SmartCaliper_ is a fresh approach to caliper design disrupting a stagnant market. We designed the SmartCaliper after seeing firsthand in the industry the limitations that modern calipers have; hence we present a fresh vision for a technology that can reduce error and increase productivity for engineers and hobbyists. The SmartCaliper allows for measurement data to be digitally transferred from the caliper to the computer.  Additionally, we offer a novel software package that integrates the SmartCaliper to not only analyze the part tolerances against its 3D model, but to also facilitate the computer-aided-designing (CAD) process .
 
To demonstrate the application in industry for the SmartCaliper, one of our team members offers two first-hand experiences from Uber ATG and Rocketlab. First at Rocketlab, working with satellite hardware, there are a number of precision parts which all require their dimensions to be verified. During the assembly process, there was a case of one of the parts not fitting correctly. Consequently, an engineer and I began taking measurements of the part that could be causing the fit to deviate from the tolerance specification in the clean chamber. These measurements are often recorded from the caliper’s screen then written onto a piece of paper, usually a notebook. This is then brought to a computer and compared. What is bizarre about this is the use of paper since it is counter-intuitive to record measurements from a digital caliper onto a piece of paper only to then check with a digital CAD model. This creates a source of error when recording the measurements and leaves no concrete log of the measurements for later use, unless they are digitized from the notebook. In this case, SmartCalipers would have streamlined this process since it seamlessly transfers caliper data to Blender with our custom addon installed, which enables the user to annotate and record the tolerance information directly into the 3D Wavefront OBJ file itself. When the annotations need to be accessed again in the future, the Blender addon is also capable of loading in and editing them. 

The second example is from working in the LIDAR division at the Uber Advanced Technologies Group. Similar to Rocketlab, Uber often has to verify dimensions and check fits for parts. There do exist numerous cases where commercial off-the-shelf (COTS) parts are purchased without drawings or with inaccurate drawings. As a result, when the engineers have to turn those parts into 3D models, they often have to measure each dimension with their calipers and manually type those dimensions into the CAD software. Despite the fact that every engineer at Uber is supplied with an expensive high-end Mitutoyo caliper that has the capability of sending data to computers, engineers still often do not use the data transferring feature. This is because the software that handles the data transfer and its integration with the CAD environment is unintuitive and overall clunky to use, which fails to expedite the 3D modeling process. SmartCaliper aims to resolve these existing issues by taking the form factor of an inexpensive upgrade kit that can be installed on any digital caliper. Our software integration is also extremely user-friendly since it only requires the user to press one button to send the data to the desired textbox in any CAD software.
 
Overall, the caliper industry has not pushed to innovate on their technologies, hence having no pressure from competitors. Ultimately, the goal of the SmartCaliper is to improve the workflow of calipers in the modern digital age and push manufacturers to innovate again. 

## 2. Market Application

The caliper market has largely been able to avoid massive change for the past decade, which translates to limited compatibility with the digitally driven engineering workflow of today. If an engineer wants to directly log measurements from their caliper in a digital format, their only option is to hope they have an exposed data link connector and the required cable. They then need to wire this into their computer and use a clunky software that will allow them to log the measurements.

The smart caliper serves to offer a simple alternative that is low in cost for both engineers and hobbyists, improving the overall caliper experience without attempting to reinvent the wheel. Today, almost every digital caliper has data link ports, which are enclosed within the caliper. We plan to sell conversion kits for many of the major caliper manufacturers such as Mitutoyo, Neiko, Starret, and more. This kit would consist of the circuit, shown in the technical summary, miniaturized into a small PCB along with a simple plastic case that mounts to the rear of the caliper body as well as a cable that hooks into the caliper's data port. We also offer our intuitive software package to anyone who purchases this kit.

Since this solution consists of very few simple parts, it would be easy to scale production and move to market with the technology seen in this hackathon. The end product would be very affordable for less than the price of most calipers due to the elegance of the design. 

## 3. Technical Summary

## 3.1 Hardware
Almost every digital caliper on the market today has a connection port on the PCB that is used to stream measurement data to the computer over a special USB adapter cable. These cables are often upwards of $100 and strangely, most of those calipers do not even make the port available, opting to use it for conducting quality-control and calibration during production. 
 
The first step of the project was to acquire a suitable caliper, we chose to use one we had on hand, which was the Neiko 01407A. This caliper proved to have a connection port tucked away under the body and required a Dremel to cut a slot for wires to be attached. These 3 wires were soldered to the caliper’s GND, Clock, and Data lines. This was then run to two transistors, which handled the 1.5v to 3.3v logic level conversion from the caliper to microcontroller respectively.
 
The microcontroller chosen was an ESP32 breakout module since it would allow for the high clock rate required to parse the data from the calipers and enable wireless data transfer. A pushbutton was also added to allow the user to choose when a measurement should be recorded without having to touch the computer.


## 3.2 Firmware
Using an oscilloscope, the clock and data lines were probed to determine how the information was encoded. We discovered that every ~40ms, the caliper would send three bytes to the computer. Each bit was marked with the falling edge of the clock line. The first 16 bits were the measurement bits (LSB to MSB), followed by three high bits, then one bit to encode the sign, followed by four remaining high bits. An interrupt was used to detect the edge of the clock pulse and handle recording the values. An additional interrupt was used to detect the user button press and send the measurement via either serial or wirelessly, depending on how the system is configured. 

## 3.3 Software Package
To maximize the potential of the SmartCaliper, we created a software package that focuses on enhancing the two main uses of a caliper:

_Function 1:_ Measuring dimensions of a part for the purpose of creating its 3D model 

_Function 2:_ Measuring dimensions of a manufactured part to compare its dimensions with its 3D model

**3.3.1 Function 1:**

When one desires to create a 3D CAD model of a physical part, the most tedious process is probably measuring its dimensions with a caliper and then manually entering those dimensions into a CAD software. To streamline the dimensioning part of the CAD process, we created a functionality in our software package that allows the user to send the caliper measurement directly to the CAD software at the press of a button. We have also tested our program in a plethora of the most popular CAD softwares, including SOLIDWORKS, Fusion360, and CATIA. However, this program was designed to work with virtually every CAD software. 

This program is accomplished using the multiprocessing module of Python as the software enables parallelism for two functions. The first function is responsible for running the user-specified CAD software. The second function continuously runs a while loop that checks for data sent from the caliper using the pySerial module; when a data packet is detected, it decodes the data and enters the correct caliper measurement into a textbox that the user clicks on in the CAD software. The program enters the measurement into the CAD software by using the pynput module, which mimics specified keystrokes. 

**3.3.2 Function 2:**

After a part is manufactured, it is common practice to use a caliper to measure the dimensions of that part to determine its tolerance and errors introduced during the manufacturing process. In order to determine the part’s tolerance, it is required to compare the manufactured part with its original 3D CAD model. To make this process faster and more intuitive, our software package includes a functionality that enables the user to input the measured dimensions and make any annotations directly onto the 3D CAD model. The user is able to view the original 3D CAD model in our software, then click on any two vertices/faces of the 3D model to generate a dimension the user wants to comment on. The software then stores any user-inputted comments, computes and logs the intended original dimension, and prompts the user to enter the part’s actual measured dimension. Similar to Function 1, the user simply needs to click one button on the SmartCaliper to transfer the measure dimension into the software without the need to type. The user can make as many of these annotations as they desire and all of that information is saved directly as comments in the 3D CAD model. By doing so, the user can use the software to load the 3D CAD model along with all of the saved annotations if the user wants to edit or append new annotations in the future. To accomplish this, we used Blender as the main viewport environment. This is because Blender is an open source CAD software that has a lot of documentation for custom AddOn development. Its native support of Python, through the Blender 2.83.0 Python API, allowed us to integrate the program developed in Function 1 into our codebase. The code contains three files: an initialization file, a panel class file, and an operator class file. The initialization file is responsible for instantiating instances of all the classes. The panel class file is responsible for the class definitions of all the custom GUI that our AddOn implements. The operator class file contains the functionality to actually execute all the desired actions (e.g. measuring the Euclidean distance between two selected vertices/faces, loading/saving annotations to the header of the .obj file, etc.).


## 4. Next Steps for  _SmartCaliper_
There are numerous hardware and software improvements we have in mind for the next stage of this project.

**4.1 Hardware:**

1. The current SmartCaliper circuit is built on a breadboard, which is only meant for prototyping purposes. We are planning to condense the current breadboard circuit into a PCB that can be mounted to the rear of calipers. This can then be sold as a kit for digital calipers that will allow people to modify their existing calipers easily. 

2. The SmartCaliper currently uses a micro USB wire to transmit the measurement data via serial. However, our original intent for using an ESP32 module was to be able to transmit the data wirelessly via WiFi, but we simply did not have time to implement that during the hackathon. Therefore, we plan to enable wireless communication between the computer and the caliper.

**4.2 Software:**

1. An immediate next step would be to add a GUI for the launch menu to enhance the user experience. We could also convert all the Python files into one executable file. 

2. An interesting idea we want to explore is add a “fix” feature that corrects the 3D model in real time based on the errors between the theoretical dimension and the measured dimension. In Blender, the user can very easily manipulate the mesh, which means we could automate that process with a click of a button. 

3. We want to implement an ML online learning algorithm that allows the user to feed the error percentage value into the model every time the user adds an annotation. Overtime, the online learning algorithm will establish a more and more accurate model that predicts the errors before the part is manufactured. This model will also be catered towards each user since it will only be receiving data from each user alone. Since each user’s manufacturing environment will be different (for instance, different users have different quality of 3D printers), it is therefore highly beneficial to have models that adapt to the user’s individual environment. 

4. When a discrepancy has been measured between the CAD model and the manufactured model, there are many ways the digital model can be fixed to account for this. For instance, the user could either just simply translate the vertex, translate the entire polygon of which the vertex is a part, or even translate several of the surrounding polygons. A Deep Neural Network could be used to learn how the user prefers to correct the CAD model in order to automate this feature as well.  Recently, there have been promising results seen with using General Adversarial Networks to CAD 3D models, and this is another type of model that could be considered as well.

5. When two vertices or faces are selected, we want to be able to change the imported obj file into X-ray mode and display a line indicating the distance being calculated. This would make the software even more user-friendly. As well, when the user selects an annotation, we want to display a coloured line on the imported 3D object to exhibit the measurement contained in the annotation.
